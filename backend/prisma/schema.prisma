// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------------------------------------------------------
// Enums
// ---------------------------------------------------------------------------

enum Role {
  AGENT
  ADMIN
}

enum MARxRequestStatus {
  PENDING
  CLAIMED
  RESOLVED
}

// ---------------------------------------------------------------------------
// Models
// ---------------------------------------------------------------------------

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  firstName           String?
  lastName            String?
  passwordHash        String
  role                Role      @default(AGENT)
  isActive            Boolean   @default(true)
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  securityQuestion    String?
  securityAnswerHash  String?
  lastLoginAt         DateTime?
  force2FA            Boolean   @default(false)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  sentMessages     Message[]                 @relation("SentMessages")
  conversations    ConversationParticipant[]
  marxRequests     MARxRequest[]             @relation("AgentRequests")
  claimedRequests  MARxRequest[]             @relation("ClaimedRequests")
  auditLogs        AuditLog[]
  refreshTokens    RefreshToken[]
  createdInvites   Invite[]                  @relation("CreatedInvites")
  unlockTokens         UnlockToken[]
  otpCodes             OtpCode[]
  passwordResetTokens  PasswordResetToken[]
  passwordHistory      PasswordHistory[]
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ConversationParticipant[]
  messages     Message[]
  marxRequest  MARxRequest?
}

/// Join table that controls which users may read a conversation.
/// Route-layer access checks MUST verify membership before returning data.
model ConversationParticipant {
  id             String       @id @default(cuid())
  userId         String
  conversationId String
  joinedAt       DateTime     @default(now())

  user         User         @relation(fields: [userId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])

  @@unique([userId, conversationId])
}

/// All message content is AES-256-GCM encrypted.
/// `encryptedContent` holds base64(ciphertext).
/// `iv` holds base64(initialization vector).
/// Decryption requires the ENCRYPTION_KEY environment variable.
/// Image fields follow the same encryption pattern as text content.
model Message {
  id               String   @id @default(cuid())
  conversationId   String
  senderId         String
  encryptedContent String   // base64-encoded AES-256-GCM ciphertext
  iv               String   // base64-encoded 12-byte IV
  authTag          String   // base64-encoded 16-byte GCM auth tag
  imageData        String?  // AES-256-GCM encrypted base64 of raw image bytes
  imageIv          String?  // base64-encoded 12-byte IV for image
  imageAuthTag     String?  // base64-encoded 16-byte GCM auth tag for image
  imageMimeType    String?  // e.g. "image/png"
  createdAt        DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id])
  sender       User         @relation("SentMessages", fields: [senderId], references: [id])
}

/// Tracks the lifecycle of an agent's MARx lookup request.
/// One request maps to one Conversation once an admin claims it.
/// Client PHI fields (identifier + ID) are AES-256-GCM encrypted at rest.
model MARxRequest {
  id             String            @id @default(cuid())
  agentId        String
  conversationId String?           @unique
  status         MARxRequestStatus @default(PENDING)
  claimedById    String?
  claimedAt      DateTime?
  resolvedAt     DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // PHI: client identity — 'NAME' | 'DOB'
  clientIdentifierType    String?
  clientIdentifier        String?  // AES-256-GCM encrypted
  clientIdentifierIv      String?
  clientIdentifierAuthTag String?

  // PHI: client ID — 'SSN' | 'MBI'
  clientIdType            String?
  clientId                String?  // AES-256-GCM encrypted
  clientIdIv              String?
  clientIdAuthTag         String?

  agent        User          @relation("AgentRequests", fields: [agentId], references: [id])
  claimedBy    User?         @relation("ClaimedRequests", fields: [claimedById], references: [id])
  conversation Conversation? @relation(fields: [conversationId], references: [id])
}

/// Single-use invite links generated by admins. Expire after 48 hours.
model Invite {
  id          String    @id @default(cuid())
  tokenHash   String    @unique  // SHA-256(plaintext token)
  createdById String
  expiresAt   DateTime
  usedAt      DateTime?
  createdAt   DateTime  @default(now())

  createdBy User @relation("CreatedInvites", fields: [createdById], references: [id])
}

/// Single-use tokens emailed to locked-out users. Expires in 1 hour.
/// User must answer their security question to consume and unlock their account.
model UnlockToken {
  id        String    @id @default(cuid())
  tokenHash String    @unique  // SHA-256(plaintext token)
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}

/// Hashed refresh tokens — plaintext is sent to the client only at issuance.
/// Token rotation is applied on every use (old token revoked, new one issued).
model RefreshToken {
  id        String    @id @default(cuid())
  tokenHash String    @unique  // SHA-256(plaintext token)
  userId    String
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}

/// 6-digit email OTP for two-factor authentication on login.
/// Hashed with SHA-256. Expires in 5 minutes. Max 5 verification attempts.
model OtpCode {
  id        String    @id @default(cuid())
  codeHash  String
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  attempts  Int       @default(0)
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}

/// Single-use tokens emailed for password reset. Expires in 1 hour.
model PasswordResetToken {
  id        String    @id @default(cuid())
  tokenHash String    @unique
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}

/// Stores the last N bcrypt hashes to prevent password reuse.
model PasswordHistory {
  id           String   @id @default(cuid())
  userId       String
  passwordHash String
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

/// Append-only HIPAA audit trail. Never delete rows from this table.
model AuditLog {
  id        String   @id @default(cuid())
  userId    String
  action    String   // e.g. "MESSAGE_SENT", "REQUEST_CLAIMED", "LOGIN"
  details   Json     // structured context (conversationId, requestId, etc.)
  ipAddress String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}
